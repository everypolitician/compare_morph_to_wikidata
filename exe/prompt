#!/usr/bin/env ruby
require 'bundler/setup'
require 'json'

require 'compare_with_wikidata'

# FIXME: it's a bit awkward having so many positional command line
# arguments: we might want to make them named options, or for the the
# command to take a configuration file specifying them instead.

if ARGV.length < 4 || ARGV.length > 5
  abort "Usage: #{$PROGRAM_NAME} EP_COUNTRY_AND_HOUSE MORPH_SCRAPER EP_ID_SCHEME WIKIDATA_MEMBERSHIP_ITEM [SCRAPER_SQL]
e.g. prompt Nigeria/Senate everypolitician-scrapers/nigeria-national-assembly nass Q19822359 \\
              \"SELECT * FROM data WHERE js_position = 'Sen'\"
e.g. prompt United-States-of-America/House tmtmtmtm/us-congress-members bioguide Q13218630
"
end

ep_country_and_house, morph_scraper, ep_id_scheme, wikidata_membership_item, scraper_sql = ARGV
scraper_sql ||= 'SELECT * FROM data'
output_formatter = ENV.fetch('PROMPT_OUTPUT_FORMATTER', 'text')

morph_list = CompareWithWikidata::MembershipList::Morph.new(
  morph_scraper:   morph_scraper,
  morph_sql_query: scraper_sql
)

morph_records = morph_list.to_a.map { |d| [d[:id], d] }.to_h

wikidata_list = CompareWithWikidata::MembershipList::Wikidata.new(
  wikidata_membership_item: wikidata_membership_item,
  # FIXME: we will probably want to select this based on the country
  # we're dealing with, but use English labels for the moment
  label_language:           'en'
)

wikidata_records = wikidata_list.to_a.map { |h| [h[:item_id], h] }.to_h

morph_wikidata_lookup = CompareWithWikidata::Mapping::EPIdentifierToWikidata.new(
  ep_slug: ep_country_and_house, ep_id_scheme: ep_id_scheme
).to_h

morph_ids_with_wikidata, morph_ids_without_wikidata = morph_records.keys.partition do |morph_id|
  morph_wikidata_lookup[morph_id]
end

wikidata_ids_from_morph = morph_ids_with_wikidata.map { |morph_id| morph_wikidata_lookup[morph_id] }
wikidata_item_to_morph_id = morph_wikidata_lookup.to_a.map(&:reverse).to_h

not_in_wikidata = wikidata_ids_from_morph - wikidata_records.keys
not_in_morph = wikidata_records.keys - wikidata_ids_from_morph

if output_formatter == 'text'
  puts 'Records matched to Wikidata but not returned by SPARQL query'
  not_in_wikidata.each do |item_id|
    morph_record = morph_records[wikidata_item_to_morph_id[item_id]]
    puts "  #{item_id} #{morph_record[:id]} #{morph_record[:name]}"
  end

  puts 'Records not in the Morph scraper, but in Wikidata:'
  not_in_morph.each do |item_id|
    wikidata_record = wikidata_records[item_id]
    puts "  #{item_id} #{wikidata_record[:url]} #{wikidata_record[:name]}"
  end

  puts 'Records in the the Morph scraper not associated with a Wikidata item:'
  morph_ids_without_wikidata.each do |morph_id|
    morph_record = morph_records[morph_id]
    puts "  #{morph_id} #{morph_record[:name]}"
  end
elsif output_formatter == 'mediawiki'
  puts 'SPARQL query used for this comparison:'
  puts "{{sparql|query=#{wikidata_list.sparql_query}}}"
  puts '== Records matched to Wikidata but not returned by SPARQL query =='

  not_in_wikidata.each do |item_id|
    morph_record = morph_records[wikidata_item_to_morph_id[item_id]]
    puts "* {{Q|#{item_id}}} #{morph_record[:id]} #{morph_record[:name]}"
  end

  puts '== Records not in the Morph scraper, but in Wikidata =='

  not_in_morph.each do |item_id|
    puts "* {{Q|#{item_id}}}"
  end

  puts '== Records in the the Morph scraper not associated with a Wikidata item =='

  morph_ids_without_wikidata.each do |morph_id|
    morph_record = morph_records[morph_id]
    puts "* #{morph_id} #{morph_record[:name]}"
  end
else
  abort "Unknown output formatter: #{output_formatter.inspect}"
end
